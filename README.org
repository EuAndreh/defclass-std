* defclass-std
  Most times, when sketching out a new class, I often commit lots of typos and forget to add an =:initform=.

  Also, the throw away class designed in the beginning may thrive and stay the same. If only there was a way to overcome these problems... There is!

  This simple macro atempts to give a very DRY and succint interface to the common =DEFCLASS= form. The goal is to offer all capabilities of a normal =DEFCLASS=, only in a more compact way.

  Everything compiles down to =DEFCLASS=.
** Usage
#+BEGIN_SRC lisp
  * (progn
      (ql:quickload :defclass-std)
      (defpackage defclass-std-user
        (:use cl defclass-std))
      (in-package defclass-std-user))
  ; => T
#+END_SRC

   A simple class defined with =DEFCLASS/STD= looks like this:
#+BEGIN_SRC
(defclass/std example ()
  ((slot1 slot2 slot3)))

; which expands to:

(DEFCLASS EXAMPLE ()
  ((SLOT1 :ACCESSOR SLOT1 :INITARG :SLOT1 :INITFORM NIL)
   (SLOT2 :ACCESSOR SLOT2 :INITARG :SLOT2 :INITFORM NIL)
   (SLOT3 :ACCESSOR SLOT3 :INITARG :SLOT3 :INITFORM NIL)))
#+END_SRC
   As you can see, by default, the macro adds three options:
   1. =:accessor= + the name of the slot
   2. =:initarg= + the name of the slot
   3. =:initform nil=

   If you want to change the =:initform= value, you can use the =:std= option:
#+BEGIN_SRC lisp
(defclass std-test ()
  ((slot :std 1)))

; expands to:

(DEFCLASS STD-TEST ()
  ((SLOT :ACCESSOR SLOT :INITARG :SLOT :INITFORM 1)))
#+END_SRC

   If you want to omit the =:initform= option, you have two ways:
   1. Use =:std :unbound= explicitly
   2. Change the value of =*default-std*=. By default it is set to =T=, so, when the =:std= option is omitted, =:initform= is set to nil. When =*default-std*= is set to nil, =:initform= is omitted when =:std= is omitted.
#+BEGIN_SRC lisp
(defclass/std omit-std ()
  ((slot :std :unbound)))

; which is equivalent to:

(setf *default-std* nil)
(defclass/std omit-std ()
  ((slot)))

; which (both) expands to:

(DEFCLASS OMIT-STD ()
  ((SLOT :ACCESSOR SLOT :INITARG :SLOT)))
#+END_SRC

   =:a=, =:i=, =:r= and =:w= are connected: when all of them are omitted, =:a= and =:i= are inserted by default.

   =:a= stands for =:accessor=, =:i= stands for =:initarg=, =:r= stands for =:reader= and =:w= stands for =:writer=.

   If any of those is present, the default (=:a= and =:i=) is omitted.
#+BEGIN_SRC lisp
(defclass/std airw ()
  ((slot1 slot2)
   (slot3 slot4 :r)
   (slot5 :w)
   (slot6 :a)
   (slot7 :ri)))

; which expands to:

(DEFCLASS AIRW ()
  ((SLOT1 :ACCESSOR SLOT1 :INITARG :SLOT1 :INITFORM NIL)
   (SLOT2 :ACCESSOR SLOT2 :INITARG :SLOT2 :INITFORM NIL)
   (SLOT3 :READER SLOT3 :INITFORM NIL)
   (SLOT4 :READER SLOT4 :INITFORM NIL)
   (SLOT5 :WRITER SLOT5 :INITFORM NIL)
   (SLOT6 :ACCESSOR SLOT6 :INITFORM NIL)
   (SLOT7 :READER SLOT7 :INITARG :SLOT7 :INITFORM NIL)))
#+END_SRC
   Note that slot7 has an =:ri= option. That's just =:r= and =:i= together.

   If you want to use =:r= and =:w= together, use =:a= instead, or you'll get an error. The same stands for =:a= + =:r= and =:a= + =:w=.

   You can choose to add the class name as a prefix for the acessor/reader/writer function. Just put =:with= or =:with-prefix= option.

#+BEGIN_SRC lisp
(defclass/std example ()
  ((slot1 :with)
   (slot2)))

; which expands to:

(DEFCLASS WITH ()
  ((SLOT1 :ACCESSOR EXAMPLE-SLOT1 :INITARG :SLOT1 :INITFORM NIL)
   (SLOT2 :ACCESSOR SLOT2 :INITARG :SLOT2 :INITFORM NIL)))
#+END_SRC

   To make a slot static (class-allocated), use =:@@= or =:static=.

   To declare the type of a slot or to add documentation to a slot, use =:type= and =:doc=, respectively.

   For real quick, concise, dense and standard class definitions, use =CLASS/STD=:
#+BEGIN_SRC lisp
(class/std example slot1 slot2 slot3)

; which expands to:

(DEFCLASS/STD EXAMPLE ()
  ((SLOT1 SLOT2 SLOT3)))

; which expands to:

(DEFCLASS EXAMPLE ()
  ((SLOT1 :ACCESSOR SLOT1 :INITARG :SLOT1 :INITFORM NIL)
   (SLOT2 :ACCESSOR SLOT2 :INITARG :SLOT2 :INITFORM NIL)
   (SLOT3 :ACCESSOR SLOT3 :INITARG :SLOT3 :INITFORM NIL)))
#+END_SRC
** Examples:
#+BEGIN_SRC lisp
(defclass/std computer (gadget)
  ((screen mouse keyboard :a :type string :with-prefix)
   (bluetooth touchpad :wi)
   (speaker microphone :r)
   (place :@@ :with :doc "Where it is" :r)
   (owner :static :std "Me" :w)))

  ; expands to:

(DEFCLASS COMPUTER (GADGET)
  ((SCREEN :ACCESSOR COMPUTER-SCREEN :INITFORM NIL :TYPE STRING)
   (MOUSE :ACCESSOR COMPUTER-MOUSE :INITFORM NIL :TYPE STRING)
   (KEYBOARD :ACCESSOR COMPUTER-KEYBOARD :INITFORM NIL :TYPE STRING)
   (BLUETOOTH :WRITER BLUETOOTH :INITARG :BLUETOOTH :INITFORM NIL)
   (TOUCHPAD :WRITER TOUCHPAD :INITARG :TOUCHPAD :INITFORM NIL)
   (SPEAKER :READER SPEAKER :INITFORM NIL)
   (MICROPHONE :READER MICROPHONE :INITFORM NIL)
   (PLACE :READER COMPUTER-PLACE :INITFORM NIL :ALLOCATION :CLASS
          :DOCUMENTATION "Where it is")
   (OWNER :WRITER OWNER :INITFORM "Me" :ALLOCATION :CLASS)))
#+END_SRC

   Real life examples:

   From [[https://github.com/AccelerationNet/cl-inflector/blob/master/langs.lisp][cl-inflector]]:
#+BEGIN_SRC lisp
(defclass language ()
  ((name :accessor name :initarg :name :initform nil)
   (plurals :accessor plurals :initarg :plurals :initform nil)
   (singulars :accessor singulars :initarg :singulars :initform nil)
   (uncountables :accessor uncountables :initarg :uncountables :initform nil)
   (irregulars :accessor irregulars :initarg :irregulars :initform nil)))

; could be written:

(defclass/std language ()
  ((name plurals singulars uncountables irregulars)))

; or, using CLASS/STD:

(class/std language name plurals singulars uncountables irregulars)
#+END_SRC
   From [[https://github.com/fukamachi/clack/blob/9804d0b57350032ebdcf8539bae376b5528ac1f6/src/core/handler.lisp][clack]]:
#+BEGIN_SRC lisp
(defclass <handler> ()
     ((server-name :type keyword
                   :initarg :server-name
                   :accessor server-name)
      (acceptor :initarg :acceptor
                :accessor acceptor)))

; could be written (with *default-std* set to nil)
(defclass/std language ()
  ((server-name :type keyword)
   (acceptor)))
#+END_SRC
   From [[https://github.com/archimag/restas/blob/3e37f868141c785d2468fab342d57cca2e2a40dd/src/route.lisp][RESTAS]]:
#+BEGIN_SRC lisp
(defclass route (routes:route)
  ((symbol :initarg :symbol :reader route-symbol)
   (module :initarg :module :initform nil :reader route-module)
   (required-method :initarg :required-method :initform nil
                    :reader route-required-method)
   (arbitrary-requirement :initarg :arbitrary-requirement :initform nil
                          :reader route-arbitrary-requirement)
   (render-method :initarg :render-method :initform #'identity)
   (headers :initarg :headers :initform nil :reader route-headers)
   (variables :initarg :variables :initform nil)
   (additional-variables :initarg :additional-variables :initform nil)))

; could be written
(defclass/std route (routes-route)
  ((symbol :ri :with-prefix :std :unbound)
   (module required-method arbitrary-requirement
           headers variables additional-variables :ri)
   (render-method :i :std #'identity)
   (header :ir)))
#+END_SRC
** Dependencies
   This project depends on the (awesome) [[http://quickutil.org][Quickutil]] library and on the [[http://common-lisp.net/project/anaphora/][Anaphora]] library. The test package uses the [[github.com/fukamachi/prove][prove]] test library.

** Installation
   1. =cd= to your [[quicklisp.org][Quicklisp]] =local-projects= folder.
   2. Clone the repo =git clone https://github.com/EuAndreh/defclass-std=.
   3. Load it with Quicklisp: =(ql:quickload :defclass-std)=

** Bugs
   If you find any bug or inconsistency in the code, or if you find it too hard to use, feel free to open an issue.

** Tests
   Or to run from the REPL:
#+BEGIN_SRC lisp
  * (asdf:test-system :defclass-std)
  ; prints lots of stuff...
  ; => T
#+END_SRC

** Author

+ André Miranda

** Copyright

Copyright (c) 2014 André Miranda

** License

Licensed under the LLGPL License.
